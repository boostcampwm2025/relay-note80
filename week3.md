# Week 3 ✌

> J089_남승현, J125_박채린, J265_차지태, J227_임민수, K010_김찬휘
> 

---

<details>
  <summary>📜 퀘스트 목차</summary>
  <ol>
    <li>
      <a href="#quest-1--ai가-직접-봐주는-오늘의-년도별-운세">Quest 1: ❄ “AI가 직접 봐주는 오늘의 년도별 운세”</a>
    </li>
    <li>
      <a href="#quest-2--ai-꿀팁-밸런스-게임--ver2">Quest 2: 🧠 “AI 꿀팁 밸런스 게임 ” ver2</a>
    </li>
    <li><a href="#quest-3--ai에게-개발자-관련-재밌는-글-작성-해달라고-하기">Quest 3: 📝 AI에게 개발자 관련 재밌는 글 작성 해달라고 하기</a></li>
    <li><a href="#quest-4--ai-면접관과-함께하는-3일-cs-퀴즈-챌린지-develop">Quest 4: 🤖 AI 면접관과 함께하는 3일 CS 퀴즈 챌린지 (develop)</a></li>
    <li><a href="#quest-5--ai와-1대1-게임으로-학습-테스트하기">Quest 5: 🎮 "AI와 1대1 게임으로 학습 테스트하기"</a></li>
  </ol>
</details>

---

# Quest 1: ❄ “AI가 직접 봐주는 오늘의 년도별 운세”

## 목표

- 매일 과제 시작 전 출생년도(예: 97년생 ~ 05년생)를 기준으로 생성한 AI 운세를 슬랙에 메시지로 공유한다.
- 운세는 각 년도별로 2~3문장 이내의 짧고 유쾌한 개발자 밈 스타일로 구성한다.
- 공유된 운세에 대해 팀원들의 이모지 반응 수가 10개 이상 달성되면 해당 날짜는 성공으로 간주한다.
- 이 과정을 최소 3일 이상 연속적으로 진행하여 팀 내 분위기를 자연스럽게 활성화한다.

## 구체적인 진행 방법

1. 팀원들의 탄생년도 리스트를 AI에게 입력하여 각 년도별 유쾌한 오늘의 운세를 생성한다
2. 운세는 너무 길지 않게 2~3문장, 재치 있는 개발자 밈 스타일로 구성
3. 과제 시작 전(최대 14시 이전까지) 슬랙 채널에 공유한다
4. 공유 시 함께 볼 수 있도록 포맷을 꾸며 공유하면 더 좋음 (예: 📅 [2000년생 오늘의 운세])
5. 유머 포함 or 긍정적인 응원 메시지를 살짝 더해도 좋음

## 프롬프트 예시

```
다음은 부스트캠프 팀원들의 탄생년도 리스트야: 97, 98, 99, 00, 01, 02, 03, 04, 05
각 년도별로 오늘의 운세를 짧고 유쾌하게 만들어줘.
개발자 밈 느낌이 살짝 섞이되 너무 어렵지 않고 재밌으면 좋겠어.
톤은 긍정적이고 대화 시작에 좋을 정도의 라이트한 농담이 섞이면 좋아.
각 운세는 2~3문장으로, 총 9개 운세를 만들어줘.

```

## 예시 결과 (참고용)

📅 2000년생 오늘의 운세
오늘은 버그가 당신을 피해 갑니다. 하지만 회의는 피해가지 않아요... 조심하세요, 회의가 Merge 될 수 있어요.

📅 1999년생 오늘의 운세
당신의 하루는 커밋처럼 깔끔할 예정! 단, 리베이스는 하지 마세요. 감정까지 섞여버릴 수 있으니까요.

📅 2003년생 오늘의 운세
오늘의 운명은 switch-case! 어떤 일이 펼쳐질지 모르지만, default는 웃음입니다.

## 추가 팁

- 하루 미션 주제나 학습 키워드(예: Git, 알고리즘, 프론트엔드 등)에 맞춰 운세 주제를 가볍게 연결해보세요
- 톤은 재미있고 긍정적으로, 간단한 이모티콘이나 밈 표현을 섞으면 반응이 더 좋아요
- 매일 동일한 형식보다는 살짝씩 변형해서 공유하면 지루함 없이 계속 즐길 수 있어요!

## 달성 기준

- AI에게 탄생년도별 운세를 요청하여 생성
- 최소 3일 이상 팀 슬랙 또는 회의에서 공유
- 각 운세 공유 시, 이모지 리액션이 10개 이상 달성하면 퀘스트 성공! 🎉

---
# Quest 2: 🧠 “AI 꿀팁 밸런스 게임 ” ver2

## 토론이나 조사
2주차에서 제공한 미션 중 다수가 ‘AI로 슬랙에 꿀팁 공유하기’ 미션을 선택했습니다.  
3주차에는 같은 맥락에서 “AI가 만들어주는 꿀팁 + 밸런스 게임” 버전으로 확장하도록 했습니다.  
일방향 정보 제공에서 한 단계 나아가, 참여형 토론과 의견 공유까지 이어질 수 있도록 설계했습니다.  
짧은 질문 하나가 커뮤니티의 분위기를 바꾸고, 다양한 시각을 나누는 계기가 됩니다.

---

## 목표
- **슬랙 메시지 작성과 공유에 익숙해지기**  
  → 평소 슬랙에 글을 올리는 것이 어렵거나 어색했던 사람들도 자연스럽게 첫 메시지를 남길 수 있도록 돕습니다.
- **재미있고 유익한 꿀팁 + 밸런스 게임으로 커뮤니티 참여 유도**  
  → 밸런스 게임은 사람들이 부담 없이 참여할 수 있는 소재입니다. 거기에 짧은 개발 꿀팁을 함께 제공하면 정보성까지 확보할 수 있습니다.
- **AI와 협업해 콘텐츠를 만들고 공유하는 경험 쌓기**  
  → AI로 빠르게 질문·아이디어·꿀팁을 생성하고, 그것을 커뮤니티에 맞게 편집·활용하면서 콘텐츠 제작 경험을 쌓습니다.

---

## 프롬프트 예시
```text
개발자나 부스트캠프 참가자가 흥미롭게 토론할 만한 밸런스 게임 질문 3개를 만들어줘. 
짧게, 투표하고 싶은 느낌으로, 이모지도 섞어줘. 가능하면 관련된 각 항목에 대한 꿀팁도 하나씩 붙여줘.
```

---

## 예시 결과
1. **테스트 스타일**  
   * TDD(Test Driven Development) vs 개발 후 테스트 작성  
   **장점**  
   * TDD → 버그 감소, 유지보수 용이  
   * 후 테스트 → 초기 구현 속도 빠름, 프로토타이핑 유리  

2. **휴식 방식**  
   * 짧은 자주 휴식(5분) vs 긴 휴식(30분 이상)  
   **장점**  
   * 짧은 휴식 → 흐름 유지, 피로 누적 방지  
   * 긴 휴식 → 완전한 회복, 새로운 관점 형성  

3. **코딩 음악**  
   * Lo-fi·재즈 vs 무소음  
   **장점**  
   * Lo-fi → 집중력 향상, 몰입 분위기 제공  
   * 무소음 → 방해 요소 최소, 깊은 몰입  

4. **버전 관리 스타일**  
   * git merge vs git rebase  
   **장점**  
   * merge → 히스토리 보존, 충돌 위험 적음  
   * rebase → 커밋 로그 깔끔, 브랜치 정리 쉬움  

5. **언어 하나만 쓴다면?**  
   * 🐍 Python vs ☕ Java  
   **장점**  
   * Python → 간단한 문법, AI·데이터 분석에 강점  
   * Java → 대규모 서비스 안정성, 광범위한 라이브러리  

6. **개발 장비**  
   * 맥북 vs 윈도우 노트북  
   **장점**  
   * 맥북 → 유닉스 기반 개발 편리, 디자인 작업 친화  
   * 윈도우 → 가격 대비 성능 좋음, 다양한 소프트웨어 호환  

---

## 추가 팁
- **짧은 꿀팁 추가**: 밸런스 게임 질문에 연결된 짧은 개발 팁을 덧붙이면 정보성과 재미를 동시에 챙길 수 있습니다.  
- **참여 유도 문구**: *“여러분은 어떤 선택을 하셨나요? 이유도 댓글로 알려주세요!”* → 댓글로 대화가 이어지도록 유도합니다.  
- **투표 참여 이모지 제안**: 각 선택지에 맞는 이모지를 지정해 참여를 쉽게 유도하세요.  
  * 예: 맥북 → ❤️ , 윈도우 → ⭐  
- **타이밍**: 오전 10시 전후, 점심 직후 등 사람들이 슬랙을 자주 확인하는 시간대에 올리면 참여율 상승  
- **해시태그 사용**: `#AI꿀팁밸런스게임` 해시태그로 콘텐츠를 묶으면 기록·검색이 쉬워집니다.

---

## 달성 기준
- **공유 횟수**: 슬랙 **공용 채널(random 등)**에 최소 1회 이상 공유한다.  
- **참여 지표**: 공유한 글에 **10표 이상의 투표** 또는 **5개 이상의 댓글/리액션** 참여를 유도한다.  
- **AI 활용 명시**: 메시지에 `(AI 생성 콘텐츠)` 표기를 추가하여 투명성을 유지한다.


---

# Quest 3: 📝 AI에게 개발자 관련 재밌는 글 작성 해달라고 하기

## 배경

토론 시간에 슬랙에서 다양한 유머와 재치 넘치시는 분들을 많이 목격했습니다.
“야 너두 재미있는 개그 할 수 있어!” 라는 시각에서 접근해봤습니다.

## 영감을 받은 내용들 조사
- 개발자용어와 애니를 섞은 부분
  
  <img width="389" height="150" alt="스크린샷 2025-08-01 오후 2 35 28" src="https://github.com/user-attachments/assets/e729982c-0049-4e4f-894a-2c432d3e6806" />

- 릴레이 프로젝트로 개발자 감성의 요일 삼행시 진행했던 부분

  <img width="744" height="283" alt="스크린샷 2025-08-01 오후 2 37 32" src="https://github.com/user-attachments/assets/612b5b31-6bf6-4caf-a7dc-f62502cebde5" />

- 개발자의 AI 유머

    <img width="436" height="467" alt="스크린샷 2025-08-01 오후 2 39 22" src="https://github.com/user-attachments/assets/1a41787f-776e-4f18-aca9-59df769c4c2d" />

## 퀘스트 소개

개발자도 재밌는 사람이라는 걸 뽐내고 표현해봅시다!

### 프롬프트 예시 1)

`스토리 주제 설명(예시, 이번 작성할 스토리는 용사의 성장 일대기야 세계관은 프론트와 백엔드 나라로 나눠져 있고 용사가 악당을 무찌르는 이야기로 작성해줘"`

### 프롬프트 예시 1의 결과)

```
《시공간 디버거: 코드 제로의 전설》
서기 3087년.
세상은 거대한 OS(오더 시스템) 위에서 작동하고 있었다.
모든 존재는 '코드'로 구성되었고, 인간은 ‘유저’로 불리며, 각자 고유한 UID를 가지고 태어났다.

세계는 프론트월드(Frontworld)와 백엔드리아(Backendria)로 나뉘어 있었고,
그 사이에는 방화벽 평원(Firewall Plains)이라는 거대한 경계가 펼쳐져 있었다.

제로의 탄생
‘제로’는 스스로를 디버깅할 수 있는 유일한 존재였다.
그는 콜 스택 언덕(Call Stack Hill)에서 버려진 유닛이었지만,
무의식 중에 루트 계정(Root Access)을 각성했다.

그날 밤, 꿈속에서 시스템의 창조주인 ‘깃마스터(Gitmaster)’가 나타나 말했다.

“너는 이 세계의 치명적인 버그를 고칠 유일한 디버거다.
시스템은 곧 무한 루프에 빠져 붕괴할 것이다.”

퀘스트의 시작
제로는 전설의 패치노트(Patch Note of Origin)를 찾아 떠났다.
여정 도중 그는 마법사 async, 전사 thread, 힐러 stackoverflow와 파티를 결성했다.

그들은 다크 캐시 미궁, 루프 호수, 세그먼트 폴트 협곡을 지나며
끊임없이 로그를 모으고, 트레이스를 따라갔다.

하지만 그들 앞을 막는 자는 다름 아닌...

데몬킹 404
그는 시스템 최하단 ‘/dev/null’에서 올라온 에러 그 자체였다.
모든 존재를 NULL로 만들고, 데이터를 잊혀지게 하는 공포의 존재.

그는 외쳤다.

“나는 존재하지 않는 존재. 넌 나를 디버깅할 수 없다.”

제로는 무너지는 세계 속에서 try-catch 마법진을 펼치며 외쳤다.

“널 try 해보지도 않고, throw 하진 않아!”

최후의 커밋
깃마스터가 남긴 마지막 키워드,
git commit -m "Fix critical bug: Restore humanity"

제로는 자신의 UID와 로그를 모두 걸고,
최후의 푸시(push) 를 감행한다.

Push complete.
System rebooting...
Welcome, User.
```

### 프롬프트 예시 2)

```
개발자가 할수 있는 낭만적인 시를 작성해줘
개발자 용어를 담아서
```

### 프롬프트 예시 2 결과)

```
깃헙에 푸시한 내 마음,  
코멘트 한 줄 없이 머지되었다.  

컴파일은 잘 되는데,  
왜 넌 내 말만 들으면 에러를 뱉니.  

async하게 기다렸지만  
await 없이 떠나버렸구나.  

커밋했던 기억들,  
리베이스해도 지워지지 않는다.  

네가 남긴 로그만  
console에 남았다.  

나는 오늘도 디버깅한다.  
사랑이라는 미지의 함수.  

return 해줘,  
그때의 너로.  
```

## 달성 기준

- slack 에 공유 후 7~10의 이모지 받기
- 댓글 2개 받기
- 피어 세션때 개그 보여주고 따봉 이모티콘 받기
- 위에 달성 못하면 다시 작성해서 올리기
- 일주일에 3번 이상 작성하기

## 추가 / 팁
- 그날의 학습 내용과 그날의 감정을 프롬프트에 녹여보세요!
- 피어세션 때 아이스 브레이킹 용도로 사용해보세요!

---

# Quest 4 :🤖 AI 면접관과 함께하는 3일 CS 퀴즈 챌린지 (develop)


## 배경

2주차에서 가지고 온 미션이지만, 비슷하게 슬랙에서 이야기를 공유해 보고 싶다는 생각이 있어 선택했습니다.
슬랙을 통해서 간단한 질문을 던진다면, 부담없이 동료들과 소통할 수 있을 것입니다.


## 퀘스트 소개

전날 미션에서 학습한 CS 지식을 활용하여, AI 면접관에게 질문을 받아 슬랙에 공유해봅니다.
이 미션은 부담 없이 소통을 시작하고, 동료들과 지식을 나누며 함께 성장하는 계기를 만듭니다.

## 진행방식
1. 전날 학습 내용을 바탕으로 AI에게 “면접 문제 스타일”의 퀴즈 생성 요청.
2. 난이도(상/중/하 1개씩)와 힌트 포함시키기
3. 슬랙에 “# 🍵 오후 3시 CS 티타임 퀴즈”의 형식으로 공유하기
4. 스레드로 답변을 받으면 이야기 나누어보기
5. 7시에 어제 문제의 정답과 & 추가 설명 공유


예시:

```
🍵 오늘의 CS 티타임 퀴즈 — Git 명령어 편

🌱 레벨 1 (쉬움)
Q1. git add 명령어의 주요 역할은 무엇인가요?

    a) 로컬 저장소의 모든 파일을 삭제한다
    b) 파일을 스테이징 영역에 추가한다
    c) 변경 사항을 원격 저장소에 직접 푸시한다
    d) 브랜치를 새로 만든다

💡 힌트: 커밋을 하기 전에 변경 사항을 임시 저장하는 단계입니다.

🌿 레벨 2 (중간)
Q2. git commit -m "메시지" 명령어를 실행하면 실제로 Git 내부에서는 어떤 일이 발생하나요?

    a) 변경된 파일이 바로 원격 저장소에 업로드된다
    b) 스테이징된 변경 사항이 스냅샷으로 저장되고, 커밋 객체가 생성된다
    c) 모든 파일의 변경 기록이 사라진다
    d) 현재 브랜치가 새로운 브랜치로 변경된다

💡 힌트: Git은 커밋을 할 때 트리 객체와 커밋 객체를 생성해 저장합니다.

🌳 레벨 3 (어려움)
Q3. 다음 상황에서 git log와 git clone의 관계를 정확히 설명한 것은 무엇인가요?

    "한 저장소를 git clone으로 복제한 후, git log를 실행하면 어떤 커밋 기록을 볼 수 있는가?"

    a) 원본 저장소의 모든 커밋 기록이 포함된다
    b) 로컬에서 만든 첫 번째 커밋 이후의 기록만 포함된다
    c) 빈 커밋 로그만 출력된다
    d) HEAD가 가리키는 브랜치의 일부 커밋만 무작위로 표시된다

💡 힌트: git clone은 원격 저장소의 전체 커밋 히스토리를 함께 가져옵니다.

```

## 달성 기준

- 최소 3일 이상 진행하기 (더 하면 더 좋음)
- 3문제씩 업로드하기
- 1회 이상 팀원이 스레드에 남겨준 답변에 댓글 달아보기

---

# Quest 5: 🎮 "AI와 1대1 게임으로 학습 테스트하기"
> 학습한 내용을 복습하고 싶지만, 재미있게 복습할 수 있는 방법은 없을까? 🤔

## 배경
게임처럼 가볍고 유쾌하게 접근하면 **기억에도 오래 남고**, **동료와의 소통도 더 활발**해질 수 있다.  
AI를 활용하면 **문제 생성이나 역할 분배를 자동화**할 수 있어 쉽게 시도할 수 있다.
또한, 혼자 학습할 때도 AI와 1:1로 대화하며 학습 효과를 점검할 수 있어, **혼자서도 가볍게 실천 가능한 복습 루틴**으로 활용 가능하다.


## 목표
- 학습한 내용을 복습하면서도 **지루하지 않게 테스트하는 방법 찾기**
- 동료들과 함께 **게임을 통해 지식 공유**하고, 친밀감도 쌓기
- AI를 활용한 **게임형 퀴즈 생성 및 진행 보조** 경험 쌓기
- 설명력, 개념 정리력, 요약 능력 향상 및 메타인지 강화
- "내가 설명하거나 문제로 낼 수 있을 만큼 이해했는가?"를 점검

## 퀘스트 방식 (형식 중 택1 또는 자유 조합)
### ① 양세찬 게임 (힌트로만 정답 맞추기)
- AI와 돌아가며 정답을 맞추는 방식
- 정답 시 1포인트 획득

### ② Jeopardy (점수판 선택 퀴즈)
- AI에게 난이도별로 `[기초/중급/심화] 퀴즈를 3개씩 생성해줘` 요청
- 점수판에서 문제를 선택해서 답변
- AI가 해설도 자동 제공 가능

### ③ Tic-Tac-Toe (정답 맞혀서 선 그리기)
- 3x3 퀴즈판을 준비 (문제는 AI가 생성)
- 맞히면 O, 틀리면 X로 칸 차지
- 삼목 만들기 대결

→ 이외 다른 게임이 있다면 활용해도 좋음!

## 프롬프트 예시

> "나랑 양세찬 게임(Call my name)을 할거야. 이번주에 학습한 git 명령어(init, add, commit, status, log, branch, switch) 관련 주제로 해볼거야. 우리는 각각 3번씩만 질문할 수 있고, 정답(git 명령어)을 먼저 맞추는 사람이 이기는 게임이야. 너가 먼저 시작해!"

> "스레드/이벤트 루프 개념에 대한 Jeopardy 퀴즈를 초급/중급/심화 각 3개씩 만들어줘.  
> 각 문제에는 점수, 질문, 정답, 해설 포함해줘."

## 참고
- [AI와 양세찬 게임(Call My Name) 하면서 복습하기 🎮](https://lucas.codesquad.kr/boostcamp-2025/digest/u/c8da9e0ed685813820636bae698f9f96:febe724575693ef3d797ee4306215f19)

## 달성 기준
- 게임을 선택 후, 스스로 룰(점수, 난이도 등)을 결정하기
- AI와 대결 하면서 학습한 내용 점검하기
- AI를 이기거나 점수 목표 달성시 퀘스트 완료 (지면 이길때까지 반복..)

# 퀘스트 선택

## J076 - Quest 4: AI 면접관과 함께하는 3일 CS 퀴즈 챌린지

선택 이유: CS 퀴즈 형식이 재미있고, 자연스럽게 학습 내용을 복습할 수 있어서입니다. 팀원들과 소통하면서 지식을 나눌 수 있는 점도 큰 매력이라고 느꼈습니다.

수행 계획: 4주차 미션에서 학습한 CS 내용을 바탕으로 난이도별 퀴즈 3문제를 만들어서  릴레이 프로젝트 시간에 공유하겠습니다.


## S030 - **Quest 5: 🎮 "AI와 1대1 게임으로 학습 테스트하기"**

선택 이유: **혼자서도 가볍게 실천 가능한 복습 루틴**으로 활용 가능하다. 게임으로 쉽게 접근할 수 있다.

수행 계획: 4주차 미션에서 복습하고 싶은 주제를 활용하여 게임을 진행한다. 


## J305 - **Quest 2: 🧠 “AI 꿀팁 밸런스 게임 ” ver2**

선택 이유 : 밸런스 게임은 차악을 고르는 게임이다. 그래서 밸런스 게임을 통해서 내가 했던 실수들을 정리할 기회가 된다고 생각했다. 

수행 계획 : 구현 과정에서 발생한 에러들을 정리하고, 만일 해당 에러가 났을 때 어떤 것이 좀 덜 끔찍한지를 고른다. 꿀팁 같은 경우에는 에러가 발생하는 이유 및 해결하는 과정을 추가하여 해결한다.


## J206 - Quest 1: ❄ “AI가 직접 봐주는 오늘의 년도별 운세”  

선택 이유 : AI 운세로 하루의 시작에 가벼운 재미를 더할 수 있을 것 같다. 나뿐만 아니라 다른 불특정 다수의 운세도 함께 받아서 공유한다는 점이 커뮤니티 내에서 친목을 다질 수 있을 것 같아서 좋다.  

수행 계획 : 아침에 체크인 후 5개 출생년도별 운세를 개발자 특성에 맞게 봐달라고 AI에게 의뢰한다. AI 운세 내용을 슬랙 Random 채널에 공유한다.  

# 퀘스트 수행

## J076 - Quest 4: AI 면접관과 함께하는 3일 CS 퀴즈 챌린지

### 객관식 문제

1. **HTTP 요청/응답**: HTTP가 상태 비저장(stateless) 프로토콜이라는 특징을 보완하기 위해 사용되는 메커니즘은 무엇인가요?
    
    a) IP 주소
    
    b) 쿠키 또는 토큰
    
    c) 포트 번호
    
    d) 라우터
    
    e) 방화벽
    
2. **TCP/IP**: TCP에서 3-way handshake 과정에서 클라이언트가 서버에 처음 보내는 메시지는 무엇인가요?
    
    a) ACK
    
    b) SYN
    
    c) FIN
    
    d) RST
    
    e) PSH
    
3. **UDP vs. TCP**: 다음 중 UDP가 TCP보다 더 적합한 사용 사례는 무엇인가요?
    
    a) 웹 브라우징
    
    b) 이메일 전송
    
    c) 파일 전송
    
    d) 실시간 스트리밍
    
    e) 데이터베이스 백업
    
4. **유니캐스트/브로드캐스트/멀티캐스트**: 다음 중 멀티캐스트 통신의 특징은 무엇인가요?
    
    a) 동일 서브넷 내 모든 호스트로 전송
    
    b) 1:1 통신
    
    c) 특정 그룹에만 메시지 전송
    
    d) 라우터를 넘어 전송 불가
    
    e) 모든 네트워크로 전송
    
5. **벡터 데이터베이스**: 벡터 데이터베이스가 전통적인 관계형 데이터베이스와 다른 주요 특징은 무엇인가요?
    
    a) 키워드 기반 검색
    
    b) 의미 기반 검색
    
    c) 테이블 기반 데이터 저장
    
    d) SQL만 사용 가능
    
    e) 데이터 무결성 제약 없음
    

### 서술형 문제

1. **클라이언트/서버 모델**: 클라이언트와 서버 간의 통신 관계를 설명하고, IP 주소와 포트의 역할을 포함하여 설명하세요.
2. **세션 vs. 연결**: 네트워크 통신에서 세션과 연결의 차이점을 설명하세요. HTTP에서 세션 ID가 상태를 유지하는 데 어떻게 도움이 됩니까?
3. **파일 시스템의 한계**: 전통적인 파일 시스템의 데이터베이스 시스템 대비 주요 한계 두 가지를 식별하고, 이러한 한계가 데이터 관리에 어떤 영향을 미치는지 설명하세요.
4. **데이터베이스 시스템**: 데이터베이스 관리 시스템(DBMS)이 다중 사용자 환경에서 데이터 일관성과 무결성을 어떻게 보장합니까? 이를 지원하는 기능의 예를 제시하세요.
5. **Word2Vec**: Word2Vec의 CBOW와 Skip-Gram 모델의 차이점을 설명하세요. Skip-Gram이 희귀 단어에 대해 더 나은 성능을 보이는 이유는 무엇입니까?
